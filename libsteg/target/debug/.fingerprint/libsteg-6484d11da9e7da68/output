{"message":"`main` function not found in crate `libsteg`","code":{"code":"E0601","explanation":"\nNo `main` function was found in a binary crate. To fix this error, add a\n`main` function. For example:\n\n```\nfn main() {\n    // Your program will start here.\n    println!(\"Hello world!\");\n}\n```\n\nIf you don't know the basics of Rust, you can go look to the Rust Book to get\nstarted: https://doc.rust-lang.org/book/\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":0,"byte_end":9180,"line_start":1,"line_end":282,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"use std::fs::File;","highlight_start":1,"highlight_end":19},{"text":"use std::io::prelude::*;","highlight_start":1,"highlight_end":25},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[derive(Debug)]","highlight_start":1,"highlight_end":17},{"text":"pub enum PPMError {","highlight_start":1,"highlight_end":20},{"text":"    BadHeader(String),","highlight_start":1,"highlight_end":23},{"text":"    BadFile(String),","highlight_start":1,"highlight_end":21},{"text":"    // IOError(io::Error),","highlight_start":1,"highlight_end":27},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[derive(Debug)]","highlight_start":1,"highlight_end":17},{"text":"pub struct PPMHeader {","highlight_start":1,"highlight_end":23},{"text":"    pub magic_number: [u8; 2],","highlight_start":1,"highlight_end":31},{"text":"    pub width: u32,","highlight_start":1,"highlight_end":20},{"text":"    pub height: u32,","highlight_start":1,"highlight_end":21},{"text":"    pub max_color_value: u32,","highlight_start":1,"highlight_end":30},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl PPMHeader {","highlight_start":1,"highlight_end":17},{"text":"    pub fn parse_from_file(f: &mut File) -> Result<PPMHeader, PPMError> {","highlight_start":1,"highlight_end":74},{"text":"        let header = PPMHeader {","highlight_start":1,"highlight_end":33},{"text":"            // magic_number: [80, 54],","highlight_start":1,"highlight_end":39},{"text":"            magic_number: PPMHeader::parse_magic_number(f)?,","highlight_start":1,"highlight_end":61},{"text":"            width: PPMHeader::string_to_u32(","highlight_start":1,"highlight_end":45},{"text":"                PPMHeader::bytes_to_ascii_string(PPMHeader::parse_width_from_file(f)?)?","highlight_start":1,"highlight_end":88},{"text":"                    .trim()","highlight_start":1,"highlight_end":28},{"text":"                    .to_string(),","highlight_start":1,"highlight_end":34},{"text":"            )?,","highlight_start":1,"highlight_end":16},{"text":"            height: PPMHeader::string_to_u32(","highlight_start":1,"highlight_end":46},{"text":"                PPMHeader::bytes_to_ascii_string(PPMHeader::parse_height_from_file(f)?)?","highlight_start":1,"highlight_end":89},{"text":"                    .trim()","highlight_start":1,"highlight_end":28},{"text":"                    .to_string(),","highlight_start":1,"highlight_end":34},{"text":"            )?,","highlight_start":1,"highlight_end":16},{"text":"            max_color_value: PPMHeader::string_to_u32(","highlight_start":1,"highlight_end":55},{"text":"                PPMHeader::bytes_to_ascii_string(parse_maximum_color_value(f)?)?","highlight_start":1,"highlight_end":81},{"text":"                    .trim()","highlight_start":1,"highlight_end":28},{"text":"                    .to_string(),","highlight_start":1,"highlight_end":34},{"text":"            )?,","highlight_start":1,"highlight_end":16},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        Ok(header)","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn parse_width_from_file(f: &mut File) -> Result<Vec<u8>, PPMError> {","highlight_start":1,"highlight_end":74},{"text":"        let mut ret = vec![0u8; 0];","highlight_start":1,"highlight_end":36},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        ret.extend(parse_one_white_space(f)?);","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        ret.extend(parse_dimension(f)?);","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        Ok(ret)","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn parse_height_from_file(f: &mut File) -> Result<Vec<u8>, PPMError> {","highlight_start":1,"highlight_end":75},{"text":"        // eprintln!(\"Parsing height\");","highlight_start":1,"highlight_end":40},{"text":"        Ok(parse_dimension(f)?)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn bytes_to_ascii_string(bytes: Vec<u8>) -> Result<String, PPMError> {","highlight_start":1,"highlight_end":75},{"text":"        String::from_utf8(bytes)","highlight_start":1,"highlight_end":33},{"text":"            .map_err(|_| PPMError::BadHeader(\"Bad String in header\".to_string()))","highlight_start":1,"highlight_end":82},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    pub fn string_to_u32(s: String) -> Result<u32, PPMError> {","highlight_start":1,"highlight_end":63},{"text":"        s.parse::<u32>()","highlight_start":1,"highlight_end":25},{"text":"            .map_err(|_| PPMError::BadHeader(\"Invalid number in header\".to_string()))","highlight_start":1,"highlight_end":86},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    fn parse_magic_number(f: &mut File) -> Result<[u8; 2], PPMError> {","highlight_start":1,"highlight_end":71},{"text":"        let mut magic_number_bytes = [0u8; 2];","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        match f.read(&mut magic_number_bytes) {","highlight_start":1,"highlight_end":48},{"text":"            Ok(2) => {","highlight_start":1,"highlight_end":23},{"text":"                // check to see if the magic number is correct!","highlight_start":1,"highlight_end":64},{"text":"                // if char::from(magic_number_bytes[0]) == 'P' && char::from","highlight_start":1,"highlight_end":77},{"text":"                let b1 = char::from(magic_number_bytes[0]);","highlight_start":1,"highlight_end":60},{"text":"                let b2 = char::from(magic_number_bytes[1]);","highlight_start":1,"highlight_end":60},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                match (b1, b2) {","highlight_start":1,"highlight_end":33},{"text":"                    ('P', '6') => Ok(magic_number_bytes),","highlight_start":1,"highlight_end":58},{"text":"                    _ => Err(PPMError::BadHeader(format!(","highlight_start":1,"highlight_end":58},{"text":"                        \"Bad Magic Number: {}{}\",","highlight_start":1,"highlight_end":50},{"text":"                        b1, b2","highlight_start":1,"highlight_end":31},{"text":"                    ))),","highlight_start":1,"highlight_end":25},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Ok(n) => Err(PPMError::BadHeader(format!(","highlight_start":1,"highlight_end":54},{"text":"                \"Could not read two bytes for magic number parsing! Read {} bytes!\",","highlight_start":1,"highlight_end":85},{"text":"                n","highlight_start":1,"highlight_end":18},{"text":"            ))),","highlight_start":1,"highlight_end":17},{"text":"            Err(err) => Err(PPMError::BadHeader(err.to_string())),","highlight_start":1,"highlight_end":67},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"#[derive(Debug)]","highlight_start":1,"highlight_end":17},{"text":"pub struct PPM {","highlight_start":1,"highlight_end":17},{"text":"    pub header: PPMHeader,","highlight_start":1,"highlight_end":27},{"text":"    pub pixels: Vec<u8>,","highlight_start":1,"highlight_end":25},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"impl PPM {","highlight_start":1,"highlight_end":11},{"text":"    /// Creates a new PPM struct from the specified path.","highlight_start":1,"highlight_end":58},{"text":"    pub fn new(path: String) -> Result<PPM, PPMError> {","highlight_start":1,"highlight_end":56},{"text":"        let mut f = match File::open(path) {","highlight_start":1,"highlight_end":45},{"text":"            Ok(f) => f,","highlight_start":1,"highlight_end":24},{"text":"            Err(err) => return Err(PPMError::BadFile(err.to_string())),","highlight_start":1,"highlight_end":72},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let header = PPMHeader::parse_from_file(&mut f)?;","highlight_start":1,"highlight_end":58},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut pixels: Vec<u8> = Vec::new();","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        match f.read_to_end(&mut pixels) {","highlight_start":1,"highlight_end":43},{"text":"            Ok(_) => Ok(PPM { header, pixels }),","highlight_start":1,"highlight_end":49},{"text":"            Err(err) => Err(PPMError::BadFile(err.to_string())),","highlight_start":1,"highlight_end":65},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn parse_dimension(f: &mut File) -> Result<Vec<u8>, PPMError> {","highlight_start":1,"highlight_end":64},{"text":"    // eprintln!(\"Parsing dimension\");","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut ret = vec![0u8; 0];","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut b = [0u8; 1];","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // now we keep reading until we hit something that is not white space","highlight_start":1,"highlight_end":74},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut digit_start_found = false;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    loop {","highlight_start":1,"highlight_end":11},{"text":"        match f.read(&mut b) {","highlight_start":1,"highlight_end":31},{"text":"            Ok(1) if !digit_start_found => {","highlight_start":1,"highlight_end":45},{"text":"                // probably need to put extra error checking","highlight_start":1,"highlight_end":61},{"text":"                // stuff here, although we should make it to","highlight_start":1,"highlight_end":61},{"text":"                // the EOF while parsing dimension Error","highlight_start":1,"highlight_end":57},{"text":"                // if we never find a digit.","highlight_start":1,"highlight_end":45},{"text":"                if is_white_space(b[0]) {","highlight_start":1,"highlight_end":42},{"text":"                    ret.extend(&b);","highlight_start":1,"highlight_end":36},{"text":"                } else if is_digit(b[0]) {","highlight_start":1,"highlight_end":43},{"text":"                    digit_start_found = true;","highlight_start":1,"highlight_end":46},{"text":"                    ret.extend(&b);","highlight_start":1,"highlight_end":36},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Ok(1) => {","highlight_start":1,"highlight_end":23},{"text":"                // either we read a digit, in which case","highlight_start":1,"highlight_end":57},{"text":"                // we are good and keep looking for more digits","highlight_start":1,"highlight_end":64},{"text":"                // or we read a white space character, in which case","highlight_start":1,"highlight_end":69},{"text":"                // we have reached the end of our width field","highlight_start":1,"highlight_end":62},{"text":"                // or we read something else","highlight_start":1,"highlight_end":45},{"text":"                // in which case we have an error","highlight_start":1,"highlight_end":50},{"text":"                if is_digit(b[0]) {","highlight_start":1,"highlight_end":36},{"text":"                    ret.extend(&b);","highlight_start":1,"highlight_end":36},{"text":"                } else if is_white_space(b[0]) {","highlight_start":1,"highlight_end":49},{"text":"                    ret.extend(&b);","highlight_start":1,"highlight_end":36},{"text":"                    return Ok(ret);","highlight_start":1,"highlight_end":36},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    return Err(PPMError::BadHeader(","highlight_start":1,"highlight_end":52},{"text":"                        \"Unexpected character when parsing dimensino in header\".to_string(),","highlight_start":1,"highlight_end":93},{"text":"                    ));","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Ok(_) => {","highlight_start":1,"highlight_end":23},{"text":"                return Err(PPMError::BadHeader(","highlight_start":1,"highlight_end":48},{"text":"                    \"EOF while parsing dimension\".to_string(),","highlight_start":1,"highlight_end":63},{"text":"                ));","highlight_start":1,"highlight_end":20},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Err(error) => {","highlight_start":1,"highlight_end":28},{"text":"                return Err(PPMError::BadHeader(error.to_string()));","highlight_start":1,"highlight_end":68},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn parse_one_white_space(f: &mut File) -> Result<Vec<u8>, PPMError> {","highlight_start":1,"highlight_end":70},{"text":"    let mut ret = vec![0u8; 0];","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut b = [0u8; 1];","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    match f.read(&mut b) {","highlight_start":1,"highlight_end":27},{"text":"        Ok(1) => {","highlight_start":1,"highlight_end":19},{"text":"            // we got one byte, if it is white space, we can stick","highlight_start":1,"highlight_end":67},{"text":"            // it into our result","highlight_start":1,"highlight_end":34},{"text":"            if is_white_space(b[0]) {","highlight_start":1,"highlight_end":38},{"text":"                ret.extend(&b);","highlight_start":1,"highlight_end":32},{"text":"                Ok(ret)","highlight_start":1,"highlight_end":24},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                Err(PPMError::BadHeader(format!(","highlight_start":1,"highlight_end":49},{"text":"                    \"Expected white space, got: {}\",","highlight_start":1,"highlight_end":53},{"text":"                    b[0]","highlight_start":1,"highlight_end":25},{"text":"                )))","highlight_start":1,"highlight_end":20},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        Ok(_) => Err(PPMError::BadHeader(","highlight_start":1,"highlight_end":42},{"text":"            \"Reached end EOF while looking for a single white space character!\".to_string(),","highlight_start":1,"highlight_end":93},{"text":"        )),","highlight_start":1,"highlight_end":12},{"text":"        Err(err) => Err(PPMError::BadHeader(err.to_string())),","highlight_start":1,"highlight_end":63},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn is_white_space(b: u8) -> bool {","highlight_start":1,"highlight_end":35},{"text":"    match char::from(b) {","highlight_start":1,"highlight_end":26},{"text":"        '\\n' | ' ' | '\\t' | '\\r' => true,","highlight_start":1,"highlight_end":42},{"text":"        _ => false,","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn is_digit(b: u8) -> bool {","highlight_start":1,"highlight_end":29},{"text":"    (b >= 48) && (b <= 57)","highlight_start":1,"highlight_end":27},{"text":"}","highlight_start":1,"highlight_end":2},{"text":"","highlight_start":1,"highlight_end":1},{"text":"fn parse_maximum_color_value(f: &mut File) -> Result<Vec<u8>, PPMError> {","highlight_start":1,"highlight_end":74},{"text":"    let mut digit_start_found = false;","highlight_start":1,"highlight_end":39},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut digit_start_index = 0;","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut ret = vec![0u8; 0];","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    let mut b = [0u8; 1];","highlight_start":1,"highlight_end":26},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    loop {","highlight_start":1,"highlight_end":11},{"text":"        // this feels done poorly...","highlight_start":1,"highlight_end":37},{"text":"        match f.read(&mut b) {","highlight_start":1,"highlight_end":31},{"text":"            Ok(1) if !digit_start_found => {","highlight_start":1,"highlight_end":45},{"text":"                if is_white_space(b[0]) {","highlight_start":1,"highlight_end":42},{"text":"                    ret.extend(&b);","highlight_start":1,"highlight_end":36},{"text":"                    digit_start_index += 1;","highlight_start":1,"highlight_end":44},{"text":"                } else if is_digit(b[0]) {","highlight_start":1,"highlight_end":43},{"text":"                    ret.extend(&b);","highlight_start":1,"highlight_end":36},{"text":"                    digit_start_found = true;","highlight_start":1,"highlight_end":46},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    return Err(PPMError::BadHeader(","highlight_start":1,"highlight_end":52},{"text":"                        \"Found a non digit when parsing max color value!\".to_string(),","highlight_start":1,"highlight_end":87},{"text":"                    ));","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Ok(1) => {","highlight_start":1,"highlight_end":23},{"text":"                if is_digit(b[0]) {","highlight_start":1,"highlight_end":36},{"text":"                    ret.extend(&b);","highlight_start":1,"highlight_end":36},{"text":"                } else if is_white_space(b[0]) {","highlight_start":1,"highlight_end":49},{"text":"                    ret.extend(&b);","highlight_start":1,"highlight_end":36},{"text":"                    // ok, we've reached the end of searching for our digits.","highlight_start":1,"highlight_end":78},{"text":"                    // let's now let's make sure that it's legit","highlight_start":1,"highlight_end":65},{"text":"                    // eprintln!(\"ret.len() = {}\", ret.len());","highlight_start":1,"highlight_end":63},{"text":"                    // eprintln!(\"ret: {:?}\", ret);","highlight_start":1,"highlight_end":52},{"text":"                    let digits = &ret[digit_start_index..ret.len() - 1];","highlight_start":1,"highlight_end":73},{"text":"                    // eprintln!(\"digits.len() = {}\", digits.len());","highlight_start":1,"highlight_end":69},{"text":"                    // eprintln!(\"digits: {:?}\", digits);","highlight_start":1,"highlight_end":58},{"text":"                    match digits.len() {","highlight_start":1,"highlight_end":41},{"text":"                        1..=2 => {","highlight_start":1,"highlight_end":35},{"text":"                            // good","highlight_start":1,"highlight_end":36},{"text":"                            return Ok(ret);","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        3 if (digits[0] <= 50 && digits[1] <= 53 && digits[2] <= 53) => {","highlight_start":1,"highlight_end":90},{"text":"                            // eprintln!(\"ret.len() = {}\", ret.len());","highlight_start":1,"highlight_end":71},{"text":"                            // eprintln!(\"ret: {:?}\", ret);","highlight_start":1,"highlight_end":60},{"text":"                            return Ok(ret);","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        _ => {","highlight_start":1,"highlight_end":31},{"text":"                            return Err(PPMError::BadHeader(","highlight_start":1,"highlight_end":60},{"text":"                                \"Max color value bigger than 255!\".to_string(),","highlight_start":1,"highlight_end":80},{"text":"                            ))","highlight_start":1,"highlight_end":31},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    return Err(PPMError::BadHeader(","highlight_start":1,"highlight_end":52},{"text":"                        \"Found a non digit when parsing max color value!\".to_string(),","highlight_start":1,"highlight_end":87},{"text":"                    ));","highlight_start":1,"highlight_end":24},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Ok(_) => {","highlight_start":1,"highlight_end":23},{"text":"                return Err(PPMError::BadHeader(","highlight_start":1,"highlight_end":48},{"text":"                    \"Reached end EOF while parsing max color value\".to_string(),","highlight_start":1,"highlight_end":81},{"text":"                ));","highlight_start":1,"highlight_end":20},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"            Err(err) => {","highlight_start":1,"highlight_end":26},{"text":"                return Err(PPMError::BadHeader(err.to_string()));","highlight_start":1,"highlight_end":66},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"consider adding a `main` function to `src/main.rs`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0601]\u001b[0m\u001b[0m\u001b[1m: `main` function not found in crate `libsteg`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:1:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::fs::File;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::io::prelude::*;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m#[derive(Debug)]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m281\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m282\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mconsider adding a `main` function to `src/main.rs`\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0601`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0601`.\u001b[0m\n"}
